{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Kubmio is a MinIO Object Store resource operator. Aim is to handle MinIO resources, such as:</p> <ul> <li>Buckets</li> <li>Policies</li> <li>Objects</li> <li>Users</li> <li>Groups</li> <li>AccessKeys</li> <li>...</li> </ul> <p>Kubmio does not manage installation and configuration of a MinIO cluster or tenant in Kubernetes. This is the role of the MinIO operator</p>"},{"location":"#main-features","title":"Main features:","text":"<ul> <li>Support all MinIO Objects as Kubernetes Resources.</li> <li>Able to handle several MinIO clusters</li> <li>Handle most of the resources properties.</li> <li>Resources naming decoration, to ensure global uniqueness and allow corporate naming rules enforcing.</li> <li>Support for LDAP connected MinIO Storage Server</li> </ul>"},{"location":"#requirement","title":"Requirement","text":"<ul> <li>Access to a Kubernetes cluster. You can use KIND to get a local cluster for testing, or run against a remote cluster.</li> <li>Support of admission webkooks</li> <li>cert-manager</li> <li>An account with full admin rights.</li> <li>A MinIO Server with admin credentials.</li> </ul>"},{"location":"cfg-architecture/","title":"Architecture","text":"<p><code>kubmio</code> is made of 3 static deployments and a dynamic one.</p> <ul> <li>The dynamic one is <code>operator</code>, which is in charge of handling all resource for a <code>tenant</code>.   There will be one <code>operator</code> deployment per <code>tenant</code>.</li> <li><code>supervisor</code> is the controller in charge of managing the <code>tenants</code> and their associated deployment.</li> <li><code>sweeper</code> is a controller in charge of several cleanup task, such a handling 'orphan' resources (Resources without Tenant).</li> <li><code>webhook</code> is a webhook handler, in charge if validating kubmio resources and setting default values.</li> </ul>"},{"location":"cfg-helm/","title":"Global Helm configuration","text":"<p>The Helm chart default values should be fine for a standard installation.</p> <p>Anyway, you may need to modify some values to adjust to your context. Here is a set of values which will be present for each of the 4 deployments.</p> <pre><code>operator|supervisor|sweeper|webhook:\n  replicaCount: 2\n\n  image:\n    pullSecrets: [ ]\n    repository: quay.io/kubotal/kubmio\n    # -- Overrides the image tag whose default is the chart appVersion.\n    tag:\n    pullPolicy: IfNotPresent\n\n  # Allow to change some logger configuration\n  logger:\n    mode: json   # json, dev\n    level: info  # error, warn, info, debug, trace\n\n  resources:\n    limits:\n      cpu: 600m\n      memory: 1Gi\n    requests:\n      cpu: 200m\n      memory: 512Mi\n</code></pre> <p>See comment for usage.</p> <p>Beside this, there is few configurations about kubmio behavior at this level:</p> <pre><code>global:\n  # To be used on resource name decoration.\n  clusterName: mycluster\n\n  tenantNamespace: \"\"   # If set, all tenant must be created in this namespace. if \"\", tenant can be created in any namespace\n\n  defaultTenant:\n    enabled: true\n    name: default\n    namespace: kubmio\n</code></pre> <ul> <li><code>global.clusterName</code> will be used on resource name decoration. See below</li> <li><code>global.tenantNamespace</code> will allow to constraint all <code>tenant</code> definition to be defined in one specific namespace.   If empty, such definition can be in any namespace (Providing of course appropriate RBAC rules has been setup)</li> <li><code>global.defaultTenant</code> will be added by the webhook to all resources definition where <code>spec.tenant</code> is empty</li> </ul>"},{"location":"cfg-tenant/","title":"Tenant configuration","text":"<p>Most of the behavior of Kubmio is configurable per tenant.</p>"},{"location":"cfg-tenant/#namespace-authorization","title":"Namespace authorization","text":"<p>A Bucket is a namespaced resource. As such, who is able to create/manage buckets resources can be controlled using Kubernetes RBAC system.</p> <p>Kubmio add a finest level of validation per MinIO tenant. Each tenant description accept a property <code>allowedNamespaces</code>. Only Kubmio resource manifest declared in one of the listed namespace will be allowed for this tenant.</p> <p>For example:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl apply -f -\n---\napiVersion: kubmio.com/v1alpha1\nkind: Tenant\nmetadata:\n  name: default\n  namespace: kubmio\nspec:\n  endpoint: minio.myminioserver.myinfra.com\n  credentials:\n    secretName: minio-root\n  ssl: false\n  watchedNamespaces:\n    - kubmio\n    - app1 \nEOF\n</code></pre> <p>All Kubmio objects creation referring to this tenant, but not in <code>kubmio</code> or  <code>app1</code> namespace will be rejected.</p> <p>Of course, if this list is null or empty, all namespaces are allowed.</p>"},{"location":"cfg-tenant/#policy-action-validation","title":"Policy action validation","text":"<p>As explained in the Policy chapter, the set of valid policy S3 action can be defined by tenant.</p> <p>By default, a list of all possible actions is injected by the webhook in each tenant definition, if the <code>spec.validActions</code> property is unset:</p> <pre><code>spec:\n  ......\n  validActions:\n  - s3:*\n  - s3:CopyObject\n  - s3:DeleteObject\n  - s3:DeleteObjects\n  - s3:DeleteObjectTagging\n  - s3:GetObject\n  - s3:GetObjectAttributes\n  ......\n</code></pre> <p>This list can be replaced by a more limited one on tenant creation.</p> <p>All action validation can also be disabled by defining an empty list:</p> <pre><code>spec:\n  ......\n  validActions: []\n</code></pre> <p>Note also the default list is configurable during initial Helm installation, by setting the property <code>webhooks.defaultValidActions</code> in the <code>values</code> file.</p>"},{"location":"cfg-tenant/#other-tenant-configuration","title":"Other tenant configuration","text":"<p>Here is a short description of other tenant resources properties:</p> <ul> <li><code>nameDecorator</code>: As previously described.</li> <li><code>alias</code>: Value for the <code>TenantAlias</code> variable in the data model for name decoration.</li> <li><code>decommissioned</code>: If set to <code>true</code> this tenant will not accept anymore new resource creation. But managing existing   one will still be possible.</li> <li><code>disabled</code>: If set to <code>true</code>, this tenant will be fully disabled.</li> <li><code>region</code>: This MinIO region. <code>us-east-1</code> by default</li> </ul>"},{"location":"cfg-tenant/#several-tenants-on-same-tenant","title":"Several tenants on same tenant.","text":"<p>This must be read: 'Several Kubmio tenant definitions pointing on the same physical Minio Tenant'.</p> <p>This is allowed by Kubmio configuration and could be of great help. For example, let say you have several independent project, with a development team for each project. But they share a common MinIO server.</p> <p>You can create a <code>tenant</code> for each project, with a name decorator including some unique project identifier, and with a set of <code>watchedNamespaces</code> related to each project.</p> <p>Doing this way, you have a complete isolation between all the different project.</p>"},{"location":"deployment/","title":"Deployment","text":"<p>To install Kubmio, just use the corresponding Helm chart:</p> <pre><code>helm -n kubmio upgrade -i --create-namespace kubmio oci://quay.io/kubotal/charts/kubmio --version 0.5.0-snapshot\n</code></pre> <p>Helm chart default values should be fine for a standard installation.</p> <p>Three pods should now be running on the <code>kubmio</code> namespace:</p> <pre><code>$ kubectl -n kubmio get pods\nNAME                                 READY   STATUS    RESTARTS      AGE\nkubmio-supervisor-66ff799f45-r8mh8   1/1     Running   9             10h\nkubmio-sweeper-5d7f7b798b-xsmjq      1/1     Running   0             10h\nkubmio-webhooks-68c4f4cb68-5g6nx     1/1     Running   0             10h\n</code></pre>"},{"location":"impedancemismatch/","title":"Kubernetes / MinIO impedance mismatch.","text":"<p>Each Kubmio resources has two instantiations: - Its k8s representation, as k8s object - Its Minio instantiation.</p> <p>These two implementation does not follow the same rules. This usual behavior for Kubernetes is to relax (do not implements) all referential constraints between objects. For example, one can successfully define a RoleBinding linking an un-existing role to an un-existing serviceAccount. May be the role and the serviceAccount will be defined later.</p> <p>We need to preserve this behavior, as it is at the hearth of Kubernetes. (For example, all deployments tool, such as helm, are unable to managed dependencies between resources).</p> <p>For the <code>PolicyBinding =&gt; Policy</code> and <code>PolicyBinding =&gt; subject</code>, there is a problem, as theses relationships can't be established on the Minio server if one or both side does not exists.</p> <p>The same problem apply for the <code>GroupBinding = Group</code> and <code>GroupBinding =&gt; User</code> relationship</p> <p>So, to be compliant with the k8s behavior, a <code>PolicyBinding</code> or <code>GroupBinding</code> k8s resource will be successfully created in all cases, and if one of its reference is missing, it will be set in an UNBOUND state. No action on the Minio server will be performed in such case.</p> <p>Then, the PolicyBinding or GroupBinding controllers will watch for User, Group and Policy creation (or deletion) to adjust its status accordingly.</p> <p>For example, if you crate a PolicyBinding between two un-existing resources, you will have the following resulting status:</p> <pre><code>status:\n  isGroup: false\n  phase: UNBOUND\n  policyMinioName: \"\"\n  subjectMinioNameOrDn: \"\"\n</code></pre> <p>And, if you create User2, the status will be:</p> <pre><code>status:\n  isGroup: false\n  phase: UNBOUND\n  policyMinioName: \"\"\n  subjectMinioNameOrDn: user2\n</code></pre> <p>And when you create Policy2, the status will be:</p> <pre><code>status:\n  isGroup: false\n  phase: READY\n  policyMinioName: policy2\n  subjectMinioNameOrDn: user2\n</code></pre> <p>And the attachment will be effective on the MinIO server.</p>"},{"location":"ldap/","title":"MinIO and LDAP","text":"<p>MinIO can be configured to </p>"},{"location":"namedecoration/","title":"Name decoration","text":"<p>Before we describe each resource, we may say some words about the 'Name d\u00e9coration' Kubmio feature.</p> <p>As Kubmio resources (Buckets, AccessKey, Policies, ...) are namespaced resources, several one can be created with the same name, in different namespace, resulting in clash on the MinIO server.</p> <p>Besides this, a MinIO server can be accessed by several Kubernetes cluster, thus allowing another level of name conflict.</p> <p>A namespaces are a way for several teams to works on a shared cluster in a fully isolated way, requiring them to coordinate about object naming would be a major drawback.</p> <p>To overcome this problem, Kubmio provide a mechanism of name decoration, allowing system administrators to define and enforce naming rules aimed to guaranty uniqueness of MinIO resource name.</p> <p>This decoration capability is built using the Go Template with the the Sprig function template library.</p> <p>The template is defined by the <code>nameDecorator</code> tenant property. For example:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl apply -f -\n---\napiVersion: kubmio.com/v1alpha1\nkind: Tenant\nmetadata:\n  name: default\n  namespace: kubmio\nspec:\n  endpoint: minio.myminioserver.myinfra.com\n  credentials:\n    secretName: minio-root\n  ssl: false\n  nameDecorator: \"{{.Cluster}}-{{.Namespace}}-{{.Name}}\"    \nEOF\n</code></pre> <p>A Bucket of name <code>mybucket</code> created in the namespace <code>default</code> will result in a bucket created on the MinIO server with the name <code>k8scluster1-default-mybucket</code>.</p> <p>The MinIO resulting bucket name will be set in the <code>spec.minioName</code> property of the resource:</p> <pre><code>$ kubectl get buckets mybucket -o yaml\napiVersion: kubmio.com/v1alpha1\nkind: Bucket\nmetadata:\n  finalizers:\n  - kubmio.com/finalizer\n  name: mybucket\n  namespace: default\n  ... (Some metadata properties removed)\nspec:\n  minioName: k8scluster1-default-mybucket\n  tenant:\n    name: default\n    namespace: kubmio\nstatus:\n  phase: READY\n</code></pre> <p>For a tenant with the <code>nameDecorator</code> feature enabled, the <code>spec.minioName</code> of each resource is under control of Kubmio and must be left empty on object creation.</p> <p>The data model for Kubmio resource decoration templating host 6 variables:</p> <ul> <li><code>Name</code>: The <code>name</code> property of the kubmio kubernetes resource.</li> <li><code>Namespace</code>: The namespace hosting the kubmio kubernetes resource.</li> <li><code>Cluster</code>: The cluster name, as defined by the configuration <code>clusterName</code> global property.</li> <li><code>TenantName</code>: The tenant name.</li> <li><code>TenantAlias</code>: The tenant alias</li> <li><code>TenantNamespace</code>: The tenant namespace</li> </ul>"},{"location":"quickstart/","title":"Quick start","text":""},{"location":"quickstart/#deployment","title":"Deployment","text":"<p>To install Kubmio, just use the corresponding Helm chart:</p> <pre><code>helm -n kubmio upgrade -i --create-namespace kubmio oci://quay.io/kubotal/charts/kubmio --version 0.5.0-snapshot\n</code></pre> <p>Helm chart default values should be fine for a standard installation.</p> <p>Three pods should now be running on the <code>kubmio</code> namespace:</p> <pre><code>$ kubectl -n kubmio get pods\nNAME                                 READY   STATUS    RESTARTS      AGE\nkubmio-supervisor-66ff799f45-r8mh8   1/1     Running   9             10h\nkubmio-sweeper-5d7f7b798b-xsmjq      1/1     Running   0             10h\nkubmio-webhooks-68c4f4cb68-5g6nx     1/1     Running   0             10h\n</code></pre>"},{"location":"quickstart/#tenant-creation","title":"Tenant creation","text":"<p>Once kubmio is deployed, you must configure a connection to your MinIO server. Such connection, called <code>tenant</code> is defined as a kubernetes resources.</p> <p>But prior to this, you must create a secret hosting the MinIO access credentials. For example:</p> <pre><code>kubectl -n kubmio create secret generic minio-root --from-literal=rootUser=minio --from-literal=rootPassword=xxxxxxxxx\n</code></pre> <p>And then the tenant can be created:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl apply -f -\n---\napiVersion: kubmio.com/v1alpha1\nkind: Tenant\nmetadata:\n  name: default\n  namespace: kubmio\nspec:\n  endpoint: minio.myminioserver.myinfra.com\n  credentials:\n    secretName: minio-root\n  ssl: false\nEOF\n</code></pre> <p>Of course, you must adjust the <code>spec.endoint</code> value. And, if you MinIO access is encrypted with SSL, see below for its configuration</p> <p>Deploying this first tenant in the <code>kubmio</code> namespace, and naming it <code>default</code> is meaningful. See below</p> <p>After few time, your tenant should reach the READY state:</p> <pre><code>$ kubectl -n kubmio get tenants\nNAME      ALIAS     DESCRIPTION   ENDPOINT                       SSL    STATUS   DISAB.   DISCOM.   AGE\ndefault   default                 minio1-ext.ingress.kubo2.mbp   true   READY    false    false     3m50s\n</code></pre> <p>A specific tenant operator deployment has been setup, with two replicas:</p> <pre><code>$ kubectl -n kubmio get pods\nNAME                                              READY   STATUS    RESTARTS   AGE\nkubmio-operator-kubmio-default-66bfdbdcc7-5hjf8   1/1     Running   0          2m42s\nkubmio-operator-kubmio-default-66bfdbdcc7-9qqhz   1/1     Running   0          2m42s\nkubmio-supervisor-5589f55c8-nfl8w                 1/1     Running   0          4h21m\nkubmio-sweeper-5d7f7b798b-s9vq7                   1/1     Running   0          5h25m\nkubmio-webhooks-677864df6d-w9wdh                  1/1     Running   0          4h21m\n</code></pre> <p>Several <code>tenants</code> can be defined in the same Kubernetes cluster. This will allow to address uses case such as:</p> <ul> <li>Several MinIO servers</li> <li>Access to the same server, but with different configuration.</li> </ul> <p>Each other Kubmio resource may define a specific tenant. If they don't, they will use the one named <code>default</code> in the <code>kubmio</code> namespace.</p>"},{"location":"quickstart/#ssl-configuration","title":"SSL configuration","text":"<p>If your MinIO server is secured with SSL (It should be), then you must enable its support and provide the corresponding Certificate Authority:</p> <pre><code>---\napiVersion: kubmio.com/v1alpha1\nkind: Tenant\nmetadata:\n  name: default\n  namespace: kubmio\nspec:\n  endpoint: minio.myminioserver.myinfra.com\n  credentials:\n    secretName: minio-root\n  ssl: true\n  certificateAuthority:\n    value: \"LS0tLS1CRUdJTiBDRVJUSUZJQ................................................LS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\"\n</code></pre> <p>The <code>ca</code> property is the base64 encoded certificate authority (CA). The CA is generally provided to you as a file with a content which look like:</p> <pre><code>-----BEGIN CERTIFICATE-----\nMIIGSzCCBDOgAwIBAgIJAN3rPrHNIFfAMA0GCSqGSIb3DQEBCwUAMHUxCzAJBgNV\nBAYTAkZSMQ4wDAYDVQQIDAVQYXJpczEOMAwGA1UEBwwFUGFyaXMxGTAXBgNVBAoM\nEE9wZW5EYXRhUGxhdGZvcm0xFjAUBgNVBAsMDUlUIERlcGFydG1lbnQxEzARBgNV\n....\nJ2D93BTA8z5cto4I5oCtfQ2GjlkfEJG863gcIT/3ieu3AI/+LATFO7+TYVqYY8SI\nwDQVxs1wOpHZOEekfO4fKW12BQ+f+K9m+j0ISFzUCA==\n-----END CERTIFICATE-----\n</code></pre> <p>On a Linux or Mac OS system, if the file is named <code>ca.crt</code>, the value to paste in the <code>ca:</code> property of the above configuration is the result of:</p> <pre><code>cat ca.crt | base64 \n</code></pre> <p>For testing purpose, you may skip this certificate validation:</p> <pre><code>---\napiVersion: kubmio.com/v1alpha1\nkind: Tenant\nmetadata:\n  name: default\n  namespace: kubmio\nspec:\n  endpoint: minio.myminioserver.myinfra.com\n  credentials:\n    secretName: minio-root\n  ssl: true\n  noCheckCertificate: true\n</code></pre>"},{"location":"quickstart/#bucket-creation","title":"Bucket creation","text":"<p>Once a tenant is setup successfully, you may create your first 'kubmio managed' MinIO bucket:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl apply -f -\n---\napiVersion: kubmio.com/v1alpha1\nkind: Bucket\nmetadata:\n    name: bucket1\nspec:\nEOF\n</code></pre> <p>After few time, your bucket should reach the READY state:</p> <pre><code>$ kubectl get --all-namespaces buckets\nNAMESPACE   NAME      TENANT NS   TENANT    MINIO NAME   STATUS   DESCRIPTION   AGE\ndefault     bucket1   kubmio      default   bucket1      READY                  29s\n</code></pre> <p>May be the word <code>bucket</code> is also used by another application. For such case, <code>kubmio</code> provide an alias: <code>mbucket</code> or <code>mbuckets</code>. Of course, you can also use the fully qualified name: <code>kubectl get buckets.kubmio.com</code></p> <p>You can check this with the MinIO console, or the <code>mc</code> MinIO CLI (here <code>minio</code> is the alias of your server).</p> <pre><code>$ mc ls minio\n[2024-07-11 17:37:40 CEST]     0B bucket1/\n\n$ mc stat minio/bucket1\nName      : bucket1\nDate      : 2024-07-11 18:21:51 CEST\nSize      : N/A\nType      : folder\n\nProperties:\n  Versioning: Un-versioned\n  Location: us-east-1\n  Anonymous: Disabled\n  ILM: Disabled\n</code></pre> <p>You can also check the resulting K8s bucket manifest:</p> <pre><code>$ kubectl get bucket bucket1 -o yaml\napiVersion: kubmio.com/v1alpha1\nkind: Bucket\nmetadata:\n  finalizers:\n  - kubmio.com/finalizer\n  name: bucket1\n  namespace: default\n  ... (Some metadata properties removed)\nspec:\n  minioName: bucket1\n  tenant:\n    name: default\n    namespace: kubmio\nstatus:\n  phase: READY\n</code></pre> <p>Some points to mention:</p> <ul> <li>There was no namespace provided in the bucket creation. So the bucket K8s object lands on the <code>default</code> namespace.   By default, a bucket can be created in any namespace. This can be restricted in the <code>tenant</code> definition.</li> <li>The <code>spec.minioName</code> property is set to the resource name by default. It is the name of the bucket on the MinIO server.</li> <li>The <code>spec.tenant</code> property is set to the default tenant, a tenant named <code>default</code> in the <code>kubmio</code> namespace.   Default tenant name and namespace can be configured during initial Helm deployment.</li> <li>The <code>status.phase</code> is set to READY, meaning the bucket creation on the MinIO server is successful.</li> <li>There is a <code>metadata.finalizers</code>. This will be used during the Bucket deletion processing.</li> <li>The <code>status.phase</code> provide information about the current object state. <code>READY</code> means the MinIO object counterpart has   been successfully created.</li> </ul>"},{"location":"quickstart/#follow-up","title":"Follow up","text":"<p>You can now deploy others Kubmio/Minio resources such as Users, Groups, AccessKey, Policy and PolicyBinding. You will find indication and sample on each resource kind definition below in this document.</p>"},{"location":"rsc-accesskeys/","title":"AccessKey","text":""},{"location":"rsc-accesskeys/#description","title":"Description","text":"<p>A common pattern for programmatic access to service like MinIO is to use 'technical account', or 'service account'. Such account are mainly credential, with a different lifecycle than a 'User' account.</p> <p>Within MinIO, such account does not exist by themselves, but are bound to a <code>User</code>. They are called <code>AccessKey</code> in the new MinIO terminology.</p> <p>A note about terminology: During its history, MinIO concept and wording has evolved. Formerly, <code>User</code> was named <code>AccessKey</code> and what is now <code>AccessKey</code> has been named <code>svcacct</code> (for 'Service Account'). There is still some rest of the old wording on some screens of the web console and on <code>mc</code> minio CLI command. This could be confusing.</p> <p>TODO: Still to implement</p>"},{"location":"rsc-buckets/","title":"Buckets","text":""},{"location":"rsc-buckets/#description","title":"Description","text":"<p>Kubmio handle most of the MinIO bucket properties. Here is a sample of a full-featured bucket resource:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl apply -f -\n---\napiVersion: kubmio.com/v1alpha1\nkind: Bucket\nmetadata:\n  name: fullbucket\n  namespace: default\nspec:\n  minioName: app1-fullbucket\n  description: Fully described bucket\n  tenant: \n    name: default\n    namespace: kubmio\n  objectLocking: True\n  versioning: True\n  quota:\n    type: hard\n    value: \"12MiB\"\n  retention:\n    # One of \"NONE\", \"GOVERNANCE\", \"COMPLIANCE\"\n    mode: GOVERNANCE\n    validity: 100\n    # One of \"DAYS\" or \"YEARS\"\n    unit: DAYS\n  tags:\n    key1: value1\n    key2: value2\nEOF\n</code></pre> <p>Note than:</p> <ul> <li><code>spec.minioName</code> is the name of the corresponding MinIO 'Bucket' object. By default, it is same as the Kubernetes   object name. But it can be different. You can define it explicitly in the object definition, or use the <code>decoration</code>   mechanism described above.</li> <li><code>description:</code> is an optional field. It is only present on the kubernetes resource, without MinIO counterpart.</li> <li>The <code>tenant</code> is explicitly set. Useful if there is several ones defined in the K8s cluster.</li> <li><code>objectLocking</code> can only be set on Bucket creation</li> <li>If <code>retention</code> is enabled, <code>objectLocking</code> will also be enabled.</li> <li>If <code>objectLocking</code> is enabled, <code>versioning</code> will also be enabled.</li> </ul> <p>Please, check the MinIO documentation for a descriptions of these properties.</p>"},{"location":"rsc-buckets/#bucket-deletion","title":"Bucket deletion","text":"<p>Deleting the bucket resource is not just removing it from the Kubernetes database. Il will also deleted the MinIO bucket. The process is the following:</p> <ul> <li>On bucket creation, a <code>metadate.finalizer</code> is set in the bucket resource.</li> <li>When the <code>delete</code> command is issued, a flag (<code>.metadata.deletionTimestamp</code>) is set on the resource.</li> <li>The Kubmio controller try to delete the Bucket on the MinIO server.</li> <li>if this deletion is successfully, the controller remove the finalizer.</li> <li>Then Kubernetes remove the Bucket resource as part of its Garbage Collection processing.</li> </ul> <p>If the bucket contains some data, the deletion will fail and the <code>bucket</code> resource will switch in <code>DELETION</code> state, with periodic retry. The user can then remove the data, and wait for the bucket to be effectively removed.</p>"},{"location":"rsc-buckets/#manual-cleanup","title":"Manual cleanup","text":"<p>There may be some cases where one may need to cleanup the bucket resources manually. For example:</p> <ul> <li>The bucket creation failed because the tenant is miss configured.</li> <li>A MinIO server was dis-commissioned without cleaning corresponding resource definition.</li> <li>The bucket was deleted on the MinIO server, without deleting the corresponding kubernetes resource.</li> <li>....</li> </ul> <p>In such case, one need to manually remove the finalizer. This may be achieved by patching the resource. For example:</p> <pre><code>kubectl -n mybucket-namespace patch buckets/mybucket --type json --patch='[{ \"op\": \"remove\", \"path\": \"/metadata/finalizers\"}]'\n</code></pre> <p>Of course, it is up to the user to ensure the bucket is also deleted on the MinIO server.</p>"},{"location":"rsc-groupbindings/","title":"GroupBinding","text":""},{"location":"rsc-groupbindings/#description","title":"Description","text":"<p>To include a <code>User</code> in a <code>Group</code>, a <code>GroupBinding</code> resource must be created:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl apply -f -\n---\napiVersion: kubmio.com/v1alpha1\nkind: GroupBinding\nmetadata:\n  name: group1-user1\nspec:\n  description: \"Add user1 to group1\"\n  group: group1\n  user:\n    name: user1\nEOF\n</code></pre> <p>You may display the resulting kubernetes manifest:</p> <pre><code>$ kubectl get groupbindings group1-user1  -o yaml\napiVersion: kubmio.com/v1alpha1\nkind: GroupBinding\nmetadata:\n  finalizers:\n  - kubmio.com/finalizer\n  name: group1-user1\n  namespace: default\n  ..... (Some data removed)\nspec:\n  description: Add user1 to group1\n  group: group1\n  tenant:\n    name: default\n    namespace: kubmio\n  user:\n    name: user1\n    namespace: default\nstatus:\n  groupMinioName: group1\n  phase: READY\n  userMinioName: user1\n</code></pre> <ul> <li>There is a <code>metadata.finalizers</code>. This will be used during the PolicyBinding deletion processing.</li> <li><code>spec.description:</code> is an optional field. It is only present on the kubernetes resource, without MinIO counterpart.</li> <li><code>spec.group</code> is the targeted <code>Group</code>. It must be in the same namespace than the <code>GroupBinding</code>.</li> <li>The <code>spec.tenant</code> property is set to the default tenant, a tenant named <code>default</code> in the <code>kubmio</code> namespace. But,   it can be set explicitly, is there is several <code>tenant</code> resources defined in the cluster.</li> <li><code>spec.user.name</code> is the targeted <code>User</code> name. </li> <li><code>spec.user.namespace</code> us the targeted <code>User</code> namespace. By default, the same namespace of the <code>GroupBinding</code>.    But it can be explicitly set to any namespace.</li> <li>The <code>status.groupMinioName</code> is set to the name of the Group on the MinIO server, which may be different of the <code>spec.group.name</code>.</li> <li>The <code>status.phase</code> provide information about the current object state. <code>READY</code> means the MinIO object counterpart has   been successfully created.</li> <li>The <code>status.userMinioName</code> is set to the name of the User on the MinIO server, which may be different of the <code>spec.user.name</code>.</li> </ul> <p>Of course, targeted User and Group must belong to the same tenant as the PolicyBinding.</p> <p>Note there is no <code>spec.minioName</code> as a binding does not generate an object on the MinIO server.</p>"},{"location":"rsc-groups/","title":"Group","text":""},{"location":"rsc-groups/#description","title":"Description","text":"<p>A minio <code>Group</code> is just a set of <code>Users</code>.</p> <p>A set of attached policies (See <code>PolicyBinding</code> above) define what all members of the group can do on the cluster.</p> <p>A <code>Group</code> is also a <code>kubmio</code> resource, so creating a group is as simple as:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl apply -f -\n---\napiVersion: kubmio.com/v1alpha1\nkind: Group\nmetadata:\n    name: group1\nspec:\n  description: A first group\nEOF\n</code></pre> <p>You can list all created groups:</p> <pre><code>$ kubectl get --all-namespaces groups.kubmio.com\nNAMESPACE   NAME     TENANT NS   TENANT    MINIO NAME   ENABLED   STATUS   DESCRIPTION\ndefault     group1   kubmio      default   group1       true      READY    A first group\n</code></pre> <p>An alias is also provided:</p> <pre><code>$ kubectl get --all-namespaces mgroups\nNAMESPACE   NAME     TENANT NS   TENANT    MINIO NAME   ENABLED   STATUS   DESCRIPTION\ndefault     group1   kubmio      default   group1       true      READY    A first group\n</code></pre> <p>And, to have a detailed look on the created <code>Group</code>:</p> <pre><code>$ kubectl -n default get  groups.kubmio.com group1 -o yaml\napiVersion: kubmio.com/v1alpha1\nkind: Group\nmetadata:\n  annotations:\n  finalizers:\n  - kubmio.com/finalizer\n  name: group1\n  namespace: default\n  ..... (Some data removed)\nspec:\n  description: A first group\n  enabled: true\n  minioName: group1\n  tenant:\n    name: default\n    namespace: kubmio\nstatus:\n  phase: READY\n</code></pre> <ul> <li>There is a <code>metadata.finalizers</code>. This will be used during the Group deletion processing.</li> <li><code>spec.minioName</code> is the name of the corresponding MinIO 'Group' object. By default, it is same as the Kubernetes.   object name. But it can be different. You can define it explicitly in the object definition, or use the <code>decoration</code>   mechanism described previously.</li> <li><code>spec.description:</code> is an optional field. It is only present on the kubernetes resource, without MinIO counterpart.</li> <li>The <code>spec.tenant</code> property is set to the default tenant, a tenant named <code>default</code> in the <code>kubmio</code> namespace. But,   it can be set explicitly, is there is several <code>tenant</code> resources defined in the cluster.</li> <li>The <code>status.phase</code> provide information about the current object state. <code>READY</code> means the MinIO object counterpart has   been successfully created.</li> </ul>"},{"location":"rsc-policies/","title":"Policy","text":""},{"location":"rsc-policies/#description","title":"Description","text":"<p>Kubmio will also allow to define MinIO policy as Kubernetes resources:</p> <p>For example, to provide full access to the bucket we created previously:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl apply -f -\n---\napiVersion: kubmio.com/v1alpha1\nkind: Policy\nmetadata:\n  name: policy1\nspec:\n  description: \"Grant access to bucket1\"\n  statements:\n    - effect: Allow\n      actions:\n        - \"*\"\n      resources:\n        - bucket: bucket1\nEOF\n</code></pre> <p>The way you define a <code>Policy</code> with kubmio is similar, but not strictly identical to how you define Policy directly in MinIO.</p> <p>You may display the resulting kubernetes manifest:</p> <pre><code>$ kubectl get policy.kubmio.com policy1 -o yaml\napiVersion: kubmio.com/v1alpha1\nkind: Policy\nmetadata:\n  finalizers:\n  - kubmio.com/finalizer\n  name: policy1\n  namespace: default\n  ....(Some data removed)\nspec:\n  description: Grant access to bucket1\n  minioName: policy1\n  statements:\n  - actions:\n    - s3:*\n    effect: Allow\n    resources:\n    - bucket: bucket1\n      paths:\n      - /*\n  tenant:\n    name: default\n    namespace: kubmio\nstatus:\n  minioPolicy:\n    Statement:\n    - Action:\n      - s3:*\n      Effect: Allow\n      Resource:\n      - arn:aws:s3:::bucket1\n      - arn:aws:s3:::bucket1/*\n    Version: \"2012-10-17\"\n  phase: READY\n</code></pre> <ul> <li>There is a <code>metadata.finalizers</code>. This will be used during the Policy deletion processing.</li> <li><code>spec.description:</code> is an optional field. It is only present on the kubernetes resource, without MinIO counterpart.</li> <li><code>spec.minioName</code> is the name of the corresponding MinIO 'Policy' object. By default, it is same as the Kubernetes   object name. But it can be different. You can define it explicitly in the object definition, or use the <code>decoration</code>   mechanism described previously.</li> <li>The <code>spec.tenant</code> property is set to the default tenant, a tenant named <code>default</code> in the <code>kubmio</code> namespace. But,   it can be set explicitly, is there is several <code>tenant</code> resources defined in the cluster.</li> <li>As a Minio Policy, a Kubmio policy is made of several <code>spec.statements</code>. With the following fields:<ul> <li>actions` is a list of S3 actions, as defined in the MinIO documentation.   The 's3:' prefix is added by the Kubmio webhook, if not present.</li> <li><code>effect</code> is <code>Allow</code> or <code>Deny</code>. See the MinIO documentation.</li> <li><code>resources</code> is a list of targeted MinIO buckets, with a path associated. If no path was provided, the Kubmio webhook   will add one with <code>/*</code>.</li> </ul> </li> <li><code>status.minioPolicy</code> is the resulting MinIO policy, as it is declared in MinIO.</li> <li>The <code>status.phase</code> provide information about the current object state. <code>READY</code> means the MinIO object counterpart has   been successfully created.</li> </ul> <p>Of course, the referenced Buckets must be managed by the same Tenant than the Policy</p> <p>An obvious question at this point is 'Why don't declare directly the MinIO policy in the Kubernetes manifest ?'. There is at least two reasons for this:</p>"},{"location":"rsc-policies/#name-decoration","title":"Name decoration","text":"<p>By using this feature, the name of the Kubernetes Bucket resource and the name of the Minio Bucket will be different. Beside this, a user can explicitly define the MinIO name of the resource.</p> <p>As we want this renaming mechanism to be transparent for the user, all the reference to object (bucket, policy, accessKey, group) are made by the k8s resource name, not the Minio name which may be decorated.</p> <p>So, Kubmio will have to handle transparently this renaming when creating the MinIO policy.</p>"},{"location":"rsc-policies/#bucket-access-control","title":"Bucket access control.","text":"<p>A usual with Kubernetes, the authorization perimeter is the namespace. So, a namespace owner wants to be sure to control who is accessing its buckets and how (RO, RW, ...)</p> <p>So, we can't afford to directly manage policies as resource in an open way (providing json as free form), as this will allow any user to create a policy to access any buckets.</p> <p>The security is ensured by the following rules: - A policy is namespaced and can only reference buckets in the same namespace - PolicyBinding (Described later) can only bind policy from its own namespace. - PolicyBinging.subject (Who will be able to use this Policy) can reference a User or a Group in another namespace.   This is how the bucket/policy owner delegate access to other namespace.</p>"},{"location":"rsc-policies/#dynamic-bucket-handling","title":"Dynamic bucket handling","text":"<p>To enforce the rule 'A Policy can only reference a bucket in the same namespace', we can't directly use the MinIO bucket name pattern mechanism. But Kubmio support its own system. For example, if you define a policy with <code>spec.statements.resources.bucket: bucket-*</code>, this will apply to all buckets which name begin with <code>bucket-</code></p> <p>Let say there is one bucket named <code>bucket-a</code>. If you create a policy in the same namespace with the following resources definition:</p> <pre><code>  resources:\n  - bucket: bucket-*\n    paths:\n    - /mydata\n</code></pre> <p>The resulting MinIO policy Resource part will be:</p> <pre><code>  Resource:\n  - arn:aws:s3:::bucket-a\n  - arn:aws:s3:::bucket-a/mydata/*\n</code></pre> <p>Now, let's say you create a new bucket <code>bucket-b</code> still in the same namespace. The resulting Minio policy Resource part will be:</p> <pre><code>  Resource:\n  - arn:aws:s3:::bucket-a\n  - arn:aws:s3:::bucket-a/mydata/*\n  - arn:aws:s3:::bucket-b\n  - arn:aws:s3:::bucket-b/mydata/*\n</code></pre> <p>The bucket creation was automatically detected and the policy adjusted accordingly.</p> <p>Technically, a MinIO policy can't be updated. So, Kubmio will delete/recreate the policy on the MinIO server.</p> <p>If you now delete the bucket <code>bucket-a</code>, the MinIO Policy will again be automatically adjusted accordingly:</p> <pre><code>  Resource:\n  - arn:aws:s3:::bucket-b\n  - arn:aws:s3:::bucket-b/mydata/*\n</code></pre> <p>If you now create a bucket <code>bucket-c</code> in ANOTHER NAMESPACE, it will be ignored for our policy.</p> <p>A specific case: If there is no bucket matching the pattern, MinIO will not accept an empty Resource array. So Kubmio will generate a policy with:</p> <pre><code>  \"Resource\":\n     - \"arn:aws:s3:::dummy_bucket\"\n</code></pre> <p>This will be also the case if you define a policy without pattern matching, but the referenced bucket does not exist.</p>"},{"location":"rsc-policies/#s3-action-validation","title":"S3 Action validation","text":"<p>Kubmio check each action set in the policy against a list of valid action, defined by tenant. This to:</p> <ul> <li>Trap typos or other errors as soon as possible. Before Policy creation, thanks to the webhook.</li> <li>As this list is defined by tenant, the set of actions can be limited by the administrator during tenant creation.</li> </ul> <p>By default, this list is fulfilled with all possible action during Tenant creation.</p> <p>Refer to Tenant configuration for more information.</p>"},{"location":"rsc-policybindings/","title":"Policy binding","text":""},{"location":"rsc-policybindings/#description","title":"Description","text":"<p>This resource will allow to attach a Policy to a User or a Group</p> <p>For example, to attach the policy 'policy1' to the user 'User1' in de 'default' namespace:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl apply -f -\n---\napiVersion: kubmio.com/v1alpha1\nkind: PolicyBinding\nmetadata:\n  name: user1-policy1\nspec:\n  description: Grant user1 access to Policy1\n  policy:\n    name: policy1\n  subject:\n    kind: User\n    name: user1\nEOF\n</code></pre> <ul> <li><code>spac.policy.name</code> is the K8s name of the targeted Policy.</li> <li><code>spec.subject.kind</code> must be set either to <code>User</code> or <code>Group</code>.</li> <li><code>spac.subject.name</code> is the K8s name of the targeted User or Group.</li> </ul> <p>You may display the resulting kubernetes manifest:</p> <pre><code>$ kubectl get policybinding.kubmio.com user1-policy1 -o yaml\napiVersion: kubmio.com/v1alpha1\nkind: PolicyBinding\nmetadata:\n  finalizers:\n  - kubmio.com/finalizer\n  name: user1-policy1\n  namespace: default\n  ....(Some data removed)\nspec:\n  description: Grant user1 access to Policy1\n  policy:\n    kind: Policy\n    name: policy1\n  subject:\n    kind: User\n    name: user1\n    namespace: default\n  tenant:\n    name: default\n    namespace: kubmio\nstatus:\n  isGroup: false\n  phase: READY\n  policyMinioName: policy1\n  subjectMinioNameOrDn: user1\n</code></pre> <ul> <li>There is a <code>metadata.finalizers</code>. This will be used during the PolicyBinding deletion processing.</li> <li><code>spec.description:</code> is an optional field. It is only present on the kubernetes resource, without MinIO counterpart.</li> <li><code>spec.policy.kind: policy</code> has been added as a default by the Kubmio webhook. This will allow for future extension,    with other type of Policy.</li> <li>There is no <code>spec.policy.namespace</code>, as the Policy MUST be in the same namespace than the binding, for security reason   (Refer to Policy description)</li> <li><code>spec.subject.namespace: default</code> has been added as a default with the current namespace. But any namespace can be set    here, to delegate permissions to other party.</li> <li>The <code>spec.tenant</code> property is set to the default tenant, a tenant named <code>default</code> in the <code>kubmio</code> namespace. But,   it can be set explicitly, is there is several <code>tenant</code> resources defined in the cluster.</li> <li>The <code>status.phase</code> provide information about the current object state. <code>READY</code> means the MinIO object counterpart has   been successfully created.</li> <li>The <code>status.policyMinioName</code> is set to the name of the policy on the MinIO server, which may be different of the <code>spec.policy.name</code>.</li> <li>The <code>status.subjectMinioNameOrDn</code> is set to the name of the user or group on the MinIO server, which may be different of the <code>spec.subject.name</code>.</li> </ul> <p>Of course, targeted User and Policy must belong to the same tenant as the PolicyBinding.</p> <p>Note there is no <code>spec.minioName</code> as a binding does not generate an object on the MinIO server.</p>"},{"location":"rsc-users/","title":"User","text":""},{"location":"rsc-users/#description","title":"Description","text":"<p>A minio <code>User</code> is an abstraction representing a human person, or an entity interacting with the MinIO cluster</p> <p>A <code>User</code> is defined by an UserName and a Password.</p> <p>A set of attached policies (See <code>PolicyBinding</code> below) define what this user can do on the cluster.</p> <p>Also, a user can also be member of a <code>Group</code>. In such case, it will also benefit of all policies attached to the group.</p> <p>With kubmio, creating a MinIO user is as simple as:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl apply -f -\n---\napiVersion: kubmio.com/v1alpha1\nkind: User\nmetadata:\n  name: user1\nspec:\n  description: A simple User\nEOF\n</code></pre> <p>You can list all created users:</p> <pre><code>$ kubectl get --all-namespaces user.kubmio.com\nNAMESPACE   NAME    TENANT NS   TENANT    MINIO NAME   ENABLED   SECRET NAME         STATUS   DESCRIPTION\ndefault     user1   kubmio      default   user1        true      kubmio-user-user1   READY\n</code></pre> <p>As for the <code>buckets</code> an alias is provided, with a 'm' as prefix:</p> <pre><code>$ kubectl get --all-namespaces musers\nNAMESPACE   NAME    TENANT NS   TENANT    MINIO NAME   ENABLED   SECRET NAME         STATUS   DESCRIPTION\ndefault     user1   kubmio      default   user1        true      kubmio-user-user1   READY\n</code></pre> <p>And have a deeper look in the <code>User</code> object:</p> <pre><code>$ kubectl get users.kubmio.com user1 -o yaml\napiVersion: kubmio.com/v1alpha1\nkind: User\nmetadata:\n  finalizers:\n  - kubmio.com/finalizer\n  name: user1\n  namespace: default\n  ....(Some data removed)\nspec:\n  description: A simple User\n  enabled: true\n  minioName: user1\n  secret:\n    name: kubmio-user-user1\n    passwordField: password\n    userNameField: userName\n  tenant:\n    name: default\n    namespace: kubmio\nstatus:\n  phase: READY\n  secretChecksum: e/dVTe11O7Dy+6vMzumfcSr7KZOWty8brm5A9QoVfBI=\n</code></pre> <ul> <li>There is a <code>metadata.finalizers</code>. This will be used during the User deletion processing.</li> <li><code>spec.minioName</code> is the name of the corresponding MinIO 'User' object. By default, it is same as the Kubernetes.   object name. But it can be different. You can define it explicitly in the object definition, or use the <code>decoration</code>   mechanism described previously.</li> <li><code>spec.description:</code> is an optional field. It is only present on the kubernetes resource, without MinIO counterpart.</li> <li>The <code>spec.tenant</code> property is set to the default tenant, a tenant named <code>default</code> in the <code>kubmio</code> namespace. But,   it can be set explicitly, is there is several <code>tenant</code> resources defined in the cluster.</li> <li><code>spec.secret.name</code> is the name of a secret hosting the user's credential. This secret has been automatically generated   by kubmio on the <code>User</code> object creation, with the data fields defined by <code>spec.secret.passwordField</code> and   <code>spec.secret.userNameField</code>.</li> <li>The <code>status.phase</code> provide information about the current object state. <code>READY</code> means the MinIO object counterpart has   been successfully created.</li> </ul> <p>The user's password has been randomly generated. It can be retrieved with:</p> <pre><code>$ kubectl get secret kubmio-user-user1 -o=jsonpath='{.data.password}' | base64 -d &amp;&amp; echo\nmeR4TZYFd6GXWPQBMAqA\n</code></pre> <p>The user login is the <code>spec.minioName</code>. For convenience, Kubmio copy it in the secret, as <code>data.userName</code> property:</p> <pre><code>$ kubectl get secret kubmio-user-user1 -o=jsonpath='{.data.userName}' | base64 -d &amp;&amp; echo\nuser1\n</code></pre> <p>With this credential, 'user1' can log on the minio console. Or, it can define an alias for using the <code>mc</code> MinIO CLI:</p> <pre><code>mc alias set user1 \"https://minio.myminioserver.myinfra.com\" user1 meR4TZYFd6GXWPQBMAqA\n</code></pre> <p>If the Tenant is configured with name decoration, the provided name must be the decorated one, (The <code>spec.minioName</code> value)</p> <p>This will not works if MinIO is configured with an LDAP server. One must use an <code>AccessKey</code> instead</p>"},{"location":"rsc-users/#disabling-a-user","title":"Disabling a user","text":"<p>A <code>User</code> has a property <code>enabled</code>. This is the counterpart of the MinIO user's flag. Modifying the property will switch the state of the MinIO user.</p> <pre><code>kubectl patch user.kubmio.com user1 --type json --patch='[{ \"op\": \"replace\", \"path\": \"/spec/enabled\", \"value\": false }]'\n</code></pre>"},{"location":"rsc-users/#setting-your-own-password","title":"Setting your own password","text":"<p>You may also prefer to provide your on password for a user. For this, you may patch the existing secret:</p> <pre><code>kubectl patch secret kubmio-user-user1  --patch='{\"stringData\": { \"password\": \"mypassword\" }}'\n</code></pre> <p>The provided password length must be between 8 and 40</p> <p>Kubmio will forward the password change to MinIO.</p> <p>You can also reset the existing password by clearing the current one:</p> <pre><code>kubectl patch secret kubmio-user-user1  --patch='{\"stringData\": { \"password\": \"\" }}'\n</code></pre> <p>In such case, kubmio will generate a new one.</p> <p>You can also create the secret PRIOR to create the user itself:</p> <pre><code>kubectl create secret generic kubmio-user-user2 --from-literal=password='mypassword2'\n</code></pre> <p>Then you can create the <code>User</code>:</p> <pre><code>cat &lt;&lt;'EOF' | kubectl apply -f -\n---\napiVersion: kubmio.com/v1alpha1\nkind: User\nmetadata:\n  name: user2\nspec:\nEOF\n</code></pre> <p>For this to works, the secret name must be <code>kubmio-user-&lt;k8sUserName&gt;</code> and there must be a field <code>data.password</code> with a valid password.</p> <p>The <code>User</code> k8s resource will take ownership of the <code>secret</code>. This means the secret will be automatically deleted with the user</p>"}]}